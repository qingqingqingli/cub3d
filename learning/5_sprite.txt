**********************SPRITE STEPS*********************************

Sprites are 2D pictures that are always facing you 

Sprites become smaller if they're further away

Techniques to draw sprites are totally different from raycasting techiniques 

Draw the sprites after the wall, floor and ceilings are drawn

Steps:
1: While raycasting the walls, store the perpendicular distance of each vertical
stripe in a 1D ZBuffer


2: Calculate the distance of each sprite to the player

3: Use this distance to sort the sprites, from furthest away to closest to the camera

4: Project the sprite on the camera plane (in 2D): subtract the player position
from the sprite position, then multiply the result with the inverse of the 2x2 
camera matrix

5: Calculate the size of the sprite on the screen (both in x and y direction) 
by using the perpendicular distance

6: Draw the sprites vertical stripe by vertical stripe, don't draw the vertical
stripe if the distance is further away than the 1D ZBuffer of the walls of the 
current stripe

7: Draw the vertical stripe pixel by pixel, make sure there's an invisible color 
or all sprites would be rectangles

**********************LEARNINGS*********************************

- Step 1: ray_len buffer
	*With malloc, how do you best free the memory?

ANSWER:
1. free it before exiting with failures
2. free it before exiting with ESC

- 2D camera matrix
It is more handy to use a 2D camera matrix, rather than representing the player with an angle
and a position

- after I malloced the 2D int array input->sprite_data.sprite_pos,
it gives me seg fault when I wanted to assign value to it. 
ISSUE: I didn't iniatiate the value. Need to initiate each int element to 0,
before assigning it new value

- it only rendered one vertical pixel
ANSWER: the y (draw_start_y) is initialsised outside of the while loop. However, it needs
to be initialised every time before the while loop starts

- It rendered multiple versions of the barrel. 
ANSWER: instead of using sprite dimensions, I used screen resolution. Therefore, it does not give 
a correct rendering


- Removed 0.5 otherwise the sprite locations shift when you move further away

	input->sprite_data.sprite_pos[i][0] = x + 0.5;
	input->sprite_data.sprite_pos[i][1] = y + 0.5;