
***********************************LEARNINGS*************************************

- A loop in the y_direction to go through every pixel to determine which texture
  pixel of the texture should be used

- Every pixel has to be drawn seperately

- Best way is to use a 2D array as screen buffer and copy it to the screen at once.
  That goes much faster

- Need an extra array for the texture. Textures are stored in the format. Need to 
  load the textures from a texture file

- res_x and res_y are needed to create a screen buffer

- texture width and height (number of pixels of the texture) are defined as well

- When you hit a wall, check which texture pixel to use.
	* The x cooridinate will be the same
	* A loop is needed to give each pixel of the vertical stripe the correct texture pixel
	* A step size is needed to determine how much to increase in the texture cooridinates
	  for every pixel in vertical screen cooridinates

- Need to turn the texture to texture[textNum][texX][texY]

- floor,  floorf,  floorl - largest integral value not greater than argument
	* floor(0.5) is 0. floor(-0.5) is -1.0

- extract the RGB value from bits_per_pixel?

int		get_r(int trgb)
{
	return ((trgb >> 8) & 0xFF);
}

int		get_g(int trgb)
{
	return ((trgb >> 16) & 0xFF);
}

int		get_b(int trgb)
{
	return ((trgb >> 24) & 0xFF);
}

- how do I store all the information? 
	array[x][y] = bits_per_pixel;
	R = get_r(array[x][y]);
	G = get_g(array[x][y]);
	B = get_b(array[x][y])

	ANSWER: You don't have to extract color. You can use the value you extracted directly

- read texture png
	* store the texture png into a 2d array (array[x][y] = color)
	* texture array is an array of std::vectors, each with a certain width * height pixels.

ANSWER: You don't necessarily need to have a 2d array, as you can extract the color value real time 
when you want to render texture(x, y)

- determine the width & height of the texture pixel (64 64 for the available ones)

ANSWER: Function mlx_xpm_file_to_image() will set the texture width and height 

- for each x coordinate with (hit == 1), run a loop to determine which texture pixel to 
  put on each pixel between (x, draw_start) to (x, draw_end)

	* Need to understand for how each pixel, how much of a texture pixel needs to be rendered
	  line_lenghth as compared to pixel height ?

ANSWER: 
- input->wall.texture_step = 1.0 * input->wall.texture_height / input->dda.line_height;
- This works as we are working on a perpendicular surface. If not, another method is needed
- NOTE: The stepping being done here is affine texture mapping, which means we can 
	interpolate linearly between two points rather than have to compute a different 
	division for each pixel. This is not perspective correct in general, but for 
	perfectly vertical walls (and also perfectly horizontal floors/ceilings) it is, 
	so we can use it for raycasting.

- Need to have a seperate structure for all the direction paths and sprite, as otherwise
mlx will be confused about which window you want to render.

- mlx sync does not work properly
	* mlx_sync requires some behaviour changes that would be weird to implement for X11.

	/* to read the png file based on which wall that is facing */
	/* (a combination of 1/0) */

- Wall rendering
	*tutorial: https://github.com/keuhdall/images_example

- need to detect which wall it is to choose the texture png to read
	*a combination of side & ray direction

- Other's approach of reading color from texture pixel 

After I use the png_file_to_image function I run the mlx_get_data_addr function on
it, just like I do when creating the images that I use to put my frames on the 
screen. And then you should be able to 'get' a pixel from it the same way you set 
a pixel on an image, just in reverse

What I read was the Getting Started page, where he explains how to make a custom 
pixel_put function, instead of the default one MLX uses (which is really really 
slow). And then I made a get_pixel function that does that in reverse, to get 
the RGB value of a pixel at a certain x,y location in an image

- After the wall was rendered, it was super slow to move around.
	* the rotation speed and move speed need to be changed
	* when you have more things to render, things will move slower so you need to change your speed

- Buffer management

Roy's ANSWER:
*	Well what you want is the following, you start with IMG_ONE and you going
to put your pixels to that image. When you're done rendering you put IMG_ONE
to window. When you start to walk you need to render a new image so now IMG_TWO is 
needed and you put your pixels to image two and when you done you put IMG_TWO to window.

*	Important with this is that you always know which image is displayed at the window at
which moment so you know which one you can modify

Mark's ANSWER

*	It might be useful to use 2 images, switching them every frame. This gave me a huge
performance boost anyway. So when img1 is on the screen, I fill in img2, then put 
that one to the screen, etc.

*	I keep track which one has been put to the screen last with a variable in my main struct

*	I made 2 subfunctions 'get_new_image()' which will give me the pointer to the one
that is not on the screen, and 'set_new_image()' which will put the one that is not
active to the screen, and toggle the variable keeping track of it

*	So in my drawing code I just ask img = get_new_image() and never need to worry about
which it is and the maintenance (edited) 

*	That worked alot to get better performance for me (and less glitching on the screen)

- frame buffer 

For each frame you render, you toggle a boolean and swap the frame pointers around

***********************************TASKS*************************************

- Change the ceilling color & floor color

*******************************NEXT STEPS*************************************

- Need to double check in gaucomolo whether my image rendering is smooth or does it still 
	jump up and down