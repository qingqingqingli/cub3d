
***********************************LEARNINGS*************************************

- A loop in the y_direction to go through every pixel to determine which texture
  pixel of the texture should be used

- Every pixel has to be drawn seperately

- Best way is to use a 2D array as screen buffer and copy it to the screen at once.
  That goes much faster

- Need an extra array for the texture. Textures are stored in the format. Need to 
  load the textures from a texture file

- res_x and res_y are needed to create a screen buffer

- texture width and height (number of pixels of the texture) are defined as well

- When you hit a wall, check which texture pixel to use.
	* The x cooridinate will be the same
	* A loop is needed to give each pixel of the vertical stripe the correct texture pixel
	* A step size is needed to determine how much to increase in the texture cooridinates
	  for every pixel in vertical screen cooridinates

- Need to turn the texture to texture[textNum][texX][texY]

- floor,  floorf,  floorl - largest integral value not greater than argument
	* floor(0.5) is 0. floor(-0.5) is -1.0

***********************************STEPS*************************************
- read texture png
	* store the texture png into a 2d array (array[x][y] = color)
	* texture array is an array of std::vectors, each with a certain width * height pixels.

- determine the width & height of the texture pixel (64 64 for the available ones)

- for each x coordinate with (hit == 1), run a loop to determine which texture pixel to 
  put on each pixel between (x, draw_start) to (x, draw_end)

	* Need to understand for how each pixel, how much of a texture pixel needs to be rendered
	  line_lenghth as compared to pixel height ??

    * Put the color to the pixel

- later it needs to be synced 
	-> make all the calculations of the pixels and print them together

***********************************QUESTIONS*************************************

- How to read png file and actually transform it into a texture array?

After I use the png_file_to_image function I run the mlx_get_data_addr function on
it, just like I do when creating the images that I use to put my frames on the 
screen. And then you should be able to 'get' a pixel from it the same way you set 
a pixel on an image, just in reverse

What I read was the Getting Started page, where he explains how to make a custom 
pixel_put function, instead of the default one MLX uses (which is really really 
slow). And then I made a get_pixel function that does that in reverse, to get 
the RGB value of a pixel at a certain x,y location in an image 

https://harm-smits.github.io/42docs/libs/minilibx/images.html

- Look into how to sync the different frames and so I don't need to create a buffer

- When do we use color with one single value or when use R/G/B values?

- within ft_calculate_texture_num(), it is always input->array[input->dda.map_x][input->dda.map_y]

- Is it that with the path to texture, you are not supposed to add .
