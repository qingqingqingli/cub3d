*******************************OVERALL STEPS*********************************

- For every x of the screen
- send out a ray
- calculate the direction of the ray
- let the ray move forward until it hits a wall
- calculate distance between hit point to a player
- calculate how high this wall needs to be drawn
- draw the wall

***********************************LEARNINGS*********************************

- to set MXing need to export DISPLAY=:0 every time I wanna render 
  an image instance

- what are the correlation and difference between map and screen measurement?
ANSWER: Only the resolution metrics are needed

- plane_orientation (0, 0.66)
Does the initialisation change based on the player orientation? 
ANSWER: It does change. West player position (-1, 0) is associated 
with a plane position of (0, -0.66)

- map_width
With an irregular map, does the width reflect the row that the player is at?
ANSWER: We don't use map width but the resolution width. 

- camera(x) & pos_x & pos_y
I need to cast the ray from the player position. Why do I need to calculate the camera(x)?
ANSWER: It will give a fishbowl kind of view if you cast it from the player position. 
Need to understand better. 

- Vector & two individual variables
What are the essential difference between a vector and two individually declared variables?
The declaration is the same, just the calculation of it is different. 

- SSH
Need to look into how to create a SSH key. 
Save the private key private and only distribute the public key. 
Upload the public SSH key.

- for DDA, is map_x the same as position_x? position_x is an int not a float
ANSWER: It needs to be double

- Need to remember that position_x represent horizontal position and 
  position_y represent vertical position
  input->array[position_y][position_x]

- How to make the loop to allow the ray casting variables to be constantly calcuated?
ANSWER: Use mlx_loop & mlx_hook & mlx_hook_loop

- What is the difference between pos_x and input->dda.map_x
ANSWER: pos_x is the specific location of where the ray is. dda.map_x shows
in which grid is the ray

- (NOAH) To consider whether to instal dual booting. If so, ask Noah for
  help to install it.
  ANSWER: Not to dual boot now as I will need to sacrifice one USB port

- camera_x_pos = (2 * x / (double)input->res_x) - 1;
  x starts from the first resolution x to the last one

- is hit a local variable or should it be part of the struct?
  while (input->dda.hit == 0)
  My guess: It's probably okay to be a local variable

- why can't we cast rays from the player position but the camera position?
  ANSWER from Bman: if you take the 'euclidian' distance, whatever is right
  in front of you is always closer than what's a little to the side. that 
  causes a fisheye effect and what we'd like is to see straight lines like 
  we would see in real life.

- What is the best formula to use for delta_dis_x & delta_dis_y? 
  Three algorithms give different answers.

	input->dda.delta_dis_x = sqrt(1 + (ray_dir_y * ray_dir_y) / (ray_dir_x * ray_dir_x));
	input->dda.delta_dis_y = sqrt(1 + (ray_dir_x * ray_dir_x) /	(ray_dir_y * ray_dir_y));

	input->dda.delta_dis_x = fabs(1 / ray_dir_x);
	input->dda.delta_dis_y = fabs(1 / ray_dir_y);

	input->dda.delta_dis_x = (ray_dir_y == 0) ? 0 :	((ray_dir_x == 0) ? 1 : abs(1 / ray_dir_x));
	input->dda.delta_dis_y = (ray_dir_x == 0) ? 0 :	((ray_dir_y == 0) ? 1 : abs(1 / ray_dir_y));

  1**input->dda.delta_dis_x is 1.852154
  1**input->dda.delta_dis_y is 1.188041
  2**input->dda.delta_dis_x is 1.000000
  2**input->dda.delta_dis_y is 1.000000
  3**input->dda.delta_dis_x is 1.000000
  3**input->dda.delta_dis_y is 1.000000

  ANSWER: 
  - change abs to fabs to give an absolute number for float number
  - abs() and fabs () functions, both are used to retrieve or calculate the absolute value. 
  - The only difference between both of them is, abs() is used to calculate the absolute value 
    for integer type numbers whereas fabs() are used for floating type numbers.
  - abs() function is use under the library file <stdlib.h> and fabs() function is use under 
    the library file <math.h>.

- what is the relationship between the square size, resolution & map width?
  For instance, res = 500, map_width = 50
  ANSWER: No real relationship between them

- currently perform dda gives seg fault. The loop is probably not correct

  ANSWER:
  - check how the values change in functions to spot where could potentially went wrong
  "print map_x and map_y values in the loops and spot that map_y would go out of bound"

  - My initial code is below, which is looking for an integer value 1 instead of '1' in 
  a character array. I'm working with an integer array and not a char array

  if (input->array[input->dda.map_y][input->dda.map_x] == 1)
		hit = 1;

  needs to change to 

  if (input->array[input->dda.map_y][input->dda.map_x] == '1')
		hit = 1;

- ways to calculate ray_len (one simple way & one complicated way)
  ANSWER: the simple way is enough. The complicated one gives all the explanation behind the calculation

- Even though you are not sure about the correctness of the entire calculation,
  try to calculate the edge cases to verify

- Choose different colors for wall, floor and ceiling so you can see 
  the depth of the different elements

- How to assign a pixel a color?
  ANSWER: use mlx. my_mlx_pixel_put(&input.img, 5, 5, 0x00FF0000);

- If I change the location, somehow it would give me seg fault
  ANSWER: I changed the original map during the flood fill algorithm. 
  The content already changed and there was no N/S/W/E in the map anymore

- This function gives segfault, because the end of the array is 0 due to 
  the spilt function. Therefore, when I changed the wider restriction, 
  it does not try to access the non-existent space, the seg fault stopped.
  int	ft_change_map_back(t_input *input)
  {
    int x;
    int y;

    x = 0;
    y = 0;
    while(input->array[y][x] != '\0') --> while(input->array[y] != 0)
    {
      while(input->array[y][x] != '\0')
      {
        if(input->array[y][x] == 'f')
          input->array[y][x] = '0';
        x++;
      }
      x = 0;
      y++;
    }
    return (0);
  }

- x < input->res_x and input->res_x make no difference
int ft_calculate_ray(t_input *input)
{
	int x; 

	x = 0;
	/* should this be < or <= */
	while (x < input->res_x)
	{
		ft_calculate_camera(input, x);
		ft_calculate_ray_dir(input);
		ft_dda(input);
		ft_draw_line(input);
		ft_put_color(input, x);
		x++;
	}
	printf("here 10\n");
	return (0);
}
ANSWER: because the x resolution starts from 0, if the x goes to 
res_x (500 for instance). It would have calculated 501 verticals, 
instead of 500

- Why is there 0.5 added to pos_x & pos_y?
  data->raycast.pos.x = x + 0.5;
	data->raycast.pos.y = y + 0.5;

0.5 will put the player at the middle of the map square

- mlx_hook & mlx_key_hook difference. What does the 2 mean?

int             close(int keycode, t_vars *vars)
{
    mlx_destroy_window(vars->mlx, vars->win);
}

    mlx_hook(vars.win, 2, 1L<<0, close, &vars);

    mlx_key_hook(vars.win, close, &vars);

mlx_key_hook only deals key events, while mlx_hook deals with all kinds 
of events. So mlx_hook is more versatile to apply to more cases

- Swapped x & y so they are consistent to the tutorial
  Need to be concious to choose which x and y to use

- How do I know when a key is pressed? How to tell which key is pressed?
  When a key is pressed, how to trigger certain action? 
  ANSWER: with mlx_hook(int keycode, t_input *input), you can define only this action is 
  taken when a certain key is pressed. In order to know the keycode value, you 
  can ask the function to print the keycode value while you press them

- How to define move_speed & rotate_speed?
	* input->move.move_speed = 0.5;
	* input->move.rotate_speed = 0.3;

  You can indeed give a value to these speed and test out how fast it is

- My structure now is:

  * Render the first frame based on initial value;
    - calculation all the variables
    - mlx_put_image_to_window(input.img.mlx, input.img.mlx_win,
	    input.img.img, 0, 0);

  * mlx_hook for all four movements & relevant calculations;
        mlx_hook(input->img.mlx_win, 2, 1L<<0, *ft_move_forward, input);
        mlx_hook(input->img.mlx_win, 2, 1L<<0, *ft_move_backward, input);
        mlx_hook(input->img.mlx_win, 2, 1L<<0, *ft_move_left, input);
        mlx_hook(input->img.mlx_win, 2, 1L<<0, *ft_move_right, input);

	* mlx_loop_hook(input->img.mlx, *ft_calculate_ray, &input); 
  --> to render the next one

  * put the image to window
    - mlx_put_image_to_window(input.img.mlx, input.img.mlx_win,
	    input.img.img, 0, 0);

ANSWER: 
  - Change to mlx_hook to one function
  - Add one mlx_key_release

	/* why is it &input and not &input.img */
	mlx_hook(input.img.mlx_win, KEY_PRESS, 1L<<0, *ft_movement, &input);
	mlx_hook(input.img.mlx_win, KEY_RELEASE, 1L<<1, *ft_release, &input);

  ANSWER: because the &input is the parameter to give to the pointer function
  *ft_movement. As it requires &input in the function ft_movement, so it won't work
  if you give &input.img

***********************************QUESTIONS*********************************

- Potential problem that I can walk across the wall

- The left & right calculation needs to be swapped

- Testing

***********************************ACTIONS*********************************

TEXTURE

SPRITE

AREAS THAT NEED TO WORK ON:

DEFINES
- Need to change all the defines to the entire variable name

FLOOD FILL ALGORITHM
- flood fill: 4 way flood fill does not detect certain edge cases. 
  It can be changed to a 8-way flood fill algorithm

- flood fill: change the starting point from the first 0 to the player position

- flood fill: need to make a copy of the original array before flood fill.
  After validating the map, free the copy version of the array 

ERROR MANAGEMENT

INPUT VALIDATION

MEMORY LEAK

CLEAN CODE

OTHERS
- (NOAH) My lldb does not work properly. Ask Noah to check if I am running it correctly

- If the player is facing west (-1, 0), why is the camera plane vector (0, -0.66)?
  Why can't it be (0, 0.66)? It will also be perpendicular
  Try it out when I can see something on the screen
