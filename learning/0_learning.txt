*******************************OVERALL STEPS*********************************

- For every x of the screen
- send out a ray
- calculate the direction of the ray
- let the ray move forward until it hits a wall
- calculate distance between hit point to a player
- calculate how high this wall needs to be drawn
- draw the wall

***********************************LEARNINGS*********************************

- to set MXing need to export DISPLAY=:0 every time I wanna render 
  an image instance

- what are the correlation and difference between map and screen measurement?
ANSWER: Only the resolution metrics are needed

- plane_orientation (0, 0.66)
Does the initialisation change based on the player orientation? 
ANSWER: It does change. West player position (-1, 0) is associated 
with a plane position of (0, -0.66)

- map_width
With an irregular map, does the width reflect the row that the player is at?
ANSWER: We don't use map width but the resolution width. 

- camera(x) & pos_x & pos_y
I need to cast the ray from the player position. Why do I need to calculate the camera(x)?
ANSWER: It will give a fishbowl kind of view if you cast it from the player position. 
Need to understand better. 

- Vector & two individual variables
What are the essential difference between a vector and two individually declared variables?
The declaration is the same, just the calculation of it is different. 

- SSH
Need to look into how to create a SSH key. 
Save the private key private and only distribute the public key. 
Upload the public SSH key.

- for DDA, is map_x the same as position_x? position_x is an int not a float
ANSWER: It needs to be double

- Need to remember that position_x represent horizontal position and 
  position_y represent vertical position
  input->array[position_y][position_x]

- How to make the loop to allow the ray casting variables to be constantly calcuated?
ANSWER: Use mlx_loop & mlx_hook & mlx_hook_loop

- What is the difference between pos_x and input->dda.map_x
ANSWER: pos_x is the specific location of where the ray is. dda.map_x shows
in which grid is the ray

- (NOAH) To consider whether to instal dual booting. If so, ask Noah for
  help to install it.
  ANSWER: Not to dual boot now as I will need to sacrifice one USB port

- camera_x_pos = (2 * x / (double)input->res_x) - 1;
  x starts from the first resolution x to the last one

- is hit a local variable or should it be part of the struct?
  while (input->dda.hit == 0)
  My guess: It's probably okay to be a local variable

- why can't we cast rays from the player position but the camera position?
  ANSWER from Bman: if you take the 'euclidian' distance, whatever is right
  in front of you is always closer than what's a little to the side. that 
  causes a fisheye effect and what we'd like is to see straight lines like 
  we would see in real life.

- What is the best formula to use for delta_dis_x & delta_dis_y? 
  Three algorithms give different answers.

	input->dda.delta_dis_x = sqrt(1 + (ray_dir_y * ray_dir_y) / (ray_dir_x * ray_dir_x));
	input->dda.delta_dis_y = sqrt(1 + (ray_dir_x * ray_dir_x) /	(ray_dir_y * ray_dir_y));

	input->dda.delta_dis_x = fabs(1 / ray_dir_x);
	input->dda.delta_dis_y = fabs(1 / ray_dir_y);

	input->dda.delta_dis_x = (ray_dir_y == 0) ? 0 :	((ray_dir_x == 0) ? 1 : abs(1 / ray_dir_x));
	input->dda.delta_dis_y = (ray_dir_x == 0) ? 0 :	((ray_dir_y == 0) ? 1 : abs(1 / ray_dir_y));

  1**input->dda.delta_dis_x is 1.852154
  1**input->dda.delta_dis_y is 1.188041
  2**input->dda.delta_dis_x is 1.000000
  2**input->dda.delta_dis_y is 1.000000
  3**input->dda.delta_dis_x is 1.000000
  3**input->dda.delta_dis_y is 1.000000

  ANSWER: 
  - change abs to fabs to give an absolute number for float number
  - abs() and fabs () functions, both are used to retrieve or calculate the absolute value. 
  - The only difference between both of them is, abs() is used to calculate the absolute value 
    for integer type numbers whereas fabs() are used for floating type numbers.
  - abs() function is use under the library file <stdlib.h> and fabs() function is use under 
    the library file <math.h>.

- what is the relationship between the square size, resolution & map width?
  For instance, res = 500, map_width = 50
  ANSWER: No real relationship between them

- currently perform dda gives seg fault. The loop is probably not correct

  ANSWER:
  - check how the values change in functions to spot where could potentially went wrong
  "print map_x and map_y values in the loops and spot that map_y would go out of bound"

  - My initial code is below, which is looking for an integer value 1 instead of '1' in 
  a character array. I'm working with an integer array and not a char array

  if (input->array[input->dda.map_y][input->dda.map_x] == 1)
		hit = 1;

  needs to change to 

  if (input->array[input->dda.map_y][input->dda.map_x] == '1')
		hit = 1;

- ways to calculate ray_len (one simple way & one complicated way)
  ANSWER: the simple way is enough. The complicated one gives all the explanation behind the calculation

- Even though you are not sure about the correctness of the entire calculation,
  try to calculate the edge cases to verify

- Choose different colors for wall, floor and ceiling so you can see 
  the depth of the different elements

- How to assign a pixel a color?
  ANSWER: use mlx. my_mlx_pixel_put(&input.img, 5, 5, 0x00FF0000);

- If I change the location, somehow it would give me seg fault
  ANSWER: I changed the original map during the flood fill algorithm. 
  The content already changed and there was no N/S/W/E in the map anymore

- This function gives segfault, because the end of the array is 0 due to 
  the spilt function. Therefore, when I changed the wider restriction, 
  it does not try to access the non-existent space, the seg fault stopped.
  int	ft_change_map_back(t_input *input)
  {
    int x;
    int y;

    x = 0;
    y = 0;
    while(input->array[y][x] != '\0') --> while(input->array[y] != 0)
    {
      while(input->array[y][x] != '\0')
      {
        if(input->array[y][x] == 'f')
          input->array[y][x] = '0';
        x++;
      }
      x = 0;
      y++;
    }
    return (0);
  }

***********************************QUESTIONS*********************************

- should x be < or <= input->res_x
int ft_calculate_ray(t_input *input)
{
	int x; 

	x = 0;
	/* should this be < or <= */
	while (x <= input->res_x)
	{
		ft_calculate_camera(input, x);
		ft_calculate_ray_dir(input);
		ft_dda(input);
		ft_draw_line(input);
		ft_put_color(input, x);
		x++;
		// printf("camera_x_pos is %f\n", camera_x_pos);
		// printf("ray_dir_x is %f\n", ray_dir_x);
		// printf("ray_dir_y is %f\n", ray_dir_y);
		// printf("input->dda.line_height is %d\n", input->dda.line_height);
		// printf("input->dda.draw_start is %d\n", input->dda.draw_start);
		// printf("input->dda.draw_end is %d\n", input->dda.draw_end);		
	}
	printf("here 10\n");
	return (0);

- If there are multiple S / N, it does not give an error but provide a 
seg fault.

***********************************ACTIONS*********************************

- Need to change all the defines to the entire variable name

- flood fill: 4 way flood fill does not detect certain edge cases. 
  It can be changed to a 8-way flood fill algorithm

- flood fill: change the starting point from the first 0 to the player position

- flood fill: need to make a copy of the original array before flood fill.
  After validating the map, free the copy version of the array 

- (NOAH) My lldb does not work properly. Ask Noah to check if I am running it correctly

- If the player is facing west (-1, 0), why is the camera plane vector (0, -0.66)?
  Why can't it be (0, 0.66)? It will also be perpendicular
  Try it out when I can see something on the screen

- Next step:
  assign different colors to wall, ceiling and floor
  draw the wall on the screen
